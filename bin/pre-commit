#!/bin/bash
#
# Run formatting and linting checks in parallel.
#
# The checks should align with our CI checks in .github/workflows/frontend-checks.yml
#
# To automatically run before each commit, copy or symlink this into .git/hooks/
#
# You can commit without running the checks by running `git commit --no-verify` if need be.

# Array to store background job PIDs
pids=()
# Array to store job names for better error reporting
jobs=()
# Array to store job status
statuses=()

# Helper function to run a job in background
run_job() {
    local name=$1
    shift
    echo "Starting: $name"
    (
        set -e
        "$@"
    ) &
    pids+=($!)
    jobs+=("$name")
}

# Run all checks in parallel
run_job "dagger fmt" bash -c "cd dagger && go fmt"

run_job "frontend checks" bash -c "cd services/frontend/www-app && yarn fmt && yarn lint && yarn tsc"

run_job "travelmux checks" bash -c "cd services/travelmux && cargo fmt && cargo clippy --all-features -- -D warnings && cargo test"

run_job "gtfout checks" bash -c "cd services/gtfs/gtfout && cargo fmt --all && cargo clippy --all-targets --all-features -- -D warnings && cargo test --all-targets --all-features"

run_job "pelias config checks" bash -c "cd services/pelias/generate_config && yarn fmt && yarn lint && yarn build"

# Wait for all background jobs and collect exit codes
echo ""
echo "Waiting for all checks to complete..."
failed=""
for i in "${!pids[@]}"; do
    pid=${pids[$i]}
    job=${jobs[$i]}
    wait $pid
    statuses+=($?)
done

echo ""
echo "Status"
echo "======"
echo ""
exit_status=0
for i in "${!statuses[@]}"; do
    job=${jobs[$i]}
    status=${statuses[$i]}

    if [ $status -eq 0 ]; then
        echo "✅ $job passed"
    else
        echo "❌ $job failed"
        exit_status=$status
    fi
done

echo ""
if [ $exit_status -ne 0 ]; then
    echo "Fix the issues and try again."
else
    echo "All checks passed!"
fi
exit $exit_status

