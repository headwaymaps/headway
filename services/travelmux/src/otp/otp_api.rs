use geo::geometry::Polygon;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Router {
    #[serde(deserialize_with = "geojson::de::deserialize_geometry")]
    pub polygon: Polygon,
    pub router_id: String,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Routers {
    pub router_info: Vec<Router>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PlanError {
    pub id: u32,
    // Readable English message text
    pub msg: String,
    // a stable message key
    pub message: String,
    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct PlanResponse {
    pub plan: Plan,

    // Note that `plan` will be present even if error is present, but plan.itinieraries will be []
    pub error: Option<PlanError>,

    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Plan {
    pub itineraries: Vec<Itinerary>,

    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Itinerary {
    /// seconds
    pub duration: u64,
    pub legs: Vec<Leg>,
    /// unix mills, UTC
    pub start_time: u64,
    /// unix mills, UTC
    pub end_time: u64,

    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Leg {
    pub mode: TransitMode,
    pub distance: f64,
    pub leg_geometry: LegGeometry,
    pub route_color: Option<String>,
    // Present, but empty, for transit legs. Non-empty for non-transit legs.
    pub steps: Vec<Step>,

    pub from: Place,
    pub to: Place,

    /// What time the leg starts, in millis since Unix epoch (UTC)
    pub start_time: u64,

    /// What time the leg starts, in millis since Unix epoch (UTC)
    pub end_time: u64,

    /// Whether there is real-time data about this Leg
    pub real_time: bool,

    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

impl Leg {
    pub(crate) fn duration_seconds(&self) -> f64 {
        (self.end_time - self.start_time) as f64 / 1000.0
    }
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Step {
    /// The distance in meters that this step takes.
    pub distance: f64,
    /// The relative direction of this step.
    pub relative_direction: RelativeDirection,
    /// The name of the street.
    pub street_name: String,
    /// The absolute (compass) direction of this step.
    pub absolute_direction: Option<AbsoluteDirection>,
    /// When exiting a highway or traffic circle, the exit name/number.
    pub exit: Option<String>,
    /// Indicates whether or not a street changes direction at an intersection.
    pub stay_on: Option<bool>,
    /// This step is on an open area, such as a plaza or train platform, and thus the directions should say something like "cross"
    pub area: Option<bool>,
    /// The name of this street was generated by the system, so we should only display it once, and generally just display right/left directions
    pub bogus_name: Option<bool>,
    /// The longitude of start of the step
    pub lon: f64,
    /// The latitude of start of the step
    pub lat: f64,
    // pub alerts: Vec<Alert>,
    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum AbsoluteDirection {
    North,
    Northeast,
    East,
    Southeast,
    South,
    Southwest,
    West,
    Northwest,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone, Copy)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum RelativeDirection {
    Depart,
    HardLeft,
    Left,
    SlightlyLeft,
    Continue,
    SlightlyRight,
    Right,
    HardRight,
    CircleClockwise,
    CircleCounterclockwise,
    Elevator,
    UturnLeft,
    UturnRight,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone, Copy)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TransitMode {
    Walk,
    Bicycle,
    Car,
    Tram,
    Subway,
    Rail,
    Bus,
    Ferry,
    CableCar,
    Gondola,
    Funicular,
    Transit,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct LegGeometry {
    pub length: f64,
    pub points: String,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone, Copy)]
#[serde(rename_all = "camelCase")]
pub struct LonLat {
    pub lat: f64,
    pub lon: f64,
}

#[derive(Debug, Deserialize, Serialize, PartialEq, Clone)]
#[serde(rename_all = "camelCase")]
pub struct Place {
    #[serde(flatten)]
    pub location: LonLat,

    /// millis since Unix epoch
    /// I think it's None iff it's the trip Origin
    pub arrival: Option<u64>,

    /// millis since Unix epoch
    /// I think it's None iff it's the trip Destination
    pub departure: Option<u64>,

    /// "Civic Center / Grand Park Station"
    /// Transit stops often have names. But this is often blank when
    /// the place is some random lat/lon (e.g. the users destination)
    pub name: Option<String>,

    #[serde(flatten)]
    pub extra: HashMap<String, serde_json::Value>,
}

use crate::valhalla::valhalla_api::ManeuverType as ValhallaManeuverType;
impl From<RelativeDirection> for ValhallaManeuverType {
    fn from(otp: RelativeDirection) -> Self {
        match otp {
            RelativeDirection::Depart => ValhallaManeuverType::Start,
            RelativeDirection::HardLeft => ValhallaManeuverType::SharpLeft,
            RelativeDirection::Left => ValhallaManeuverType::Left,
            RelativeDirection::SlightlyLeft => ValhallaManeuverType::SlightLeft,
            RelativeDirection::Continue => ValhallaManeuverType::Continue,
            RelativeDirection::SlightlyRight => ValhallaManeuverType::SlightRight,
            RelativeDirection::Right => ValhallaManeuverType::Right,
            RelativeDirection::HardRight => ValhallaManeuverType::SharpRight,
            RelativeDirection::CircleClockwise => ValhallaManeuverType::RoundaboutEnter,
            RelativeDirection::CircleCounterclockwise => ValhallaManeuverType::RoundaboutEnter,
            RelativeDirection::Elevator => ValhallaManeuverType::ElevatorEnter,
            RelativeDirection::UturnLeft => ValhallaManeuverType::UturnLeft,
            RelativeDirection::UturnRight => ValhallaManeuverType::UturnRight,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_walk_serialization() {
        let mode = TransitMode::Walk;
        let serialized = serde_json::to_string(&mode).unwrap();
        assert_eq!(serialized, "\"WALK\"");
    }

    #[test]
    fn test_walk_deserialization() {
        let json = "\"WALK\"";
        let deserialized: TransitMode = serde_json::from_str(json).unwrap();
        assert_eq!(deserialized, TransitMode::Walk);
    }

    #[test]
    fn test_cable_car_serialization() {
        let mode = TransitMode::CableCar;
        let serialized = serde_json::to_string(&mode).unwrap();
        assert_eq!(serialized, "\"CABLE_CAR\"");
    }

    #[test]
    fn test_cable_car_deserialization() {
        let json = "\"CABLE_CAR\"";
        let deserialized: TransitMode = serde_json::from_str(json).unwrap();
        assert_eq!(deserialized, TransitMode::CableCar);
    }
}
